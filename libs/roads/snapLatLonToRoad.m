function [latLonOnRoad, xYOnRoad, roadSegs, nearestSegs] ...
    = snapLatLonToRoad( ...
    latLon, roadName, deg2utm_speZone, utm2deg_speZone, ...
    roads, dataSetUtmStruct)
%SNAPLATLONTOROAD Snap a GPS location to the specified road.
% Required inputs:
%   - latLon
%     The (latitude, longitude) for the point of interest.
%   - roadName
%     The name for the destination road. Note: it shoud be based on the
%     road (instead of the mile marker) data set.
%   - deg2utm_speZone
%
% Optional inputs:
%   - roads
%     The roads generated by loadIndotRoads.m.
%   - dataSetUtmStruct
%     The UTM_STRUCT generated when loading roads/mileMarkers. Note: we are
%     assuming the UTM struct is the same for both roads and milemarkers.
%   - deg2utm_speZone, utm2deg_speZone
%     Functions to use for conversions between GPS and UTM.
%
% Outputs:
%   - latLonOnRoad
%     The resultant (latitude, longitude) on the road.
%   - xYOnRoad
%     The resultant UTM (x, y) on the road.
%   - roadSegs
%     The road segments with the desired road name.
%   - nearestSegs
%     The road segments that have the nearest distance to the point of
%     interest.
%
% Yaguang Zhang, Purdue, 02/03/2021

if ~exist('roads', 'var')
    if ~evalin('base', "exist('indotRoads', 'var')")
        evalin('base', "loadIndotRoads");
    end
    roads = evalin('base', 'indotRoads');
end

if ~exist('dataSetUtmStruct', 'var')
    dataSetUtmStruct = evalin('base', "UTM_STRUCT");
end

% We only need to worry about segments from the destination road.
roadSegs = getRoadSegsByRoadName(roadName, roads);

% Project the coordinates into the UMT system used for roads.
[X, Y] = mfwdtran(dataSetUtmStruct, latLon(1), latLon(2));
% Find the nearest road segment(s).
[nearestSegs] = findNearestRoadSeg(X, Y, roadSegs);

% Find the resultant point in the specified UTM zone.
[xp, yp] = deg2utm_speZone(latLon(1), latLon(2));

nearestSegUtmPolylines = roadSegsToUtmPolylines( ...
    nearestSegs, deg2utm_speZone);
% Add a padding row [nan, nan] for each segment, just in case.
nearestSegUtmPolylinesWithNanPaddings = cellfun(@(l) [l; nan nan], ...
    nearestSegUtmPolylines, 'UniformOutput', false);
nearestSegUtmPolylinesWithNanPaddings = vertcat( ...
    nearestSegUtmPolylinesWithNanPaddings{:});
xv = nearestSegUtmPolylinesWithNanPaddings(:,1);
yv = nearestSegUtmPolylinesWithNanPaddings(:,2);
[~, x_d_min, y_d_min] = p_poly_dist(xp, yp, xv, yv, false);

xYOnRoad = [x_d_min, y_d_min];

latLonOnRoad = nan(1,2);
[latLonOnRoad(1), latLonOnRoad(2)]= utm2deg_speZone(x_d_min, y_d_min);

end
% EOF
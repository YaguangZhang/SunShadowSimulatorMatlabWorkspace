function [roadName, mile, INDOT_MILE_MARKERS_ROADNAME_LABELS, ...
    nearestSegs, nearestDist] = ...
    gpsCoor2MileMarker(lat, lon, ...
    indotMileMarkers, indotRoads, UTM_STRUCT, ...
    INDOT_MILE_MARKERS_ROADNAME_LABELS)
% GPSCOOR2MILEMARKER Convert GPS coordinates on INDOT roads (centerline
% 2019) to road name and mile marker.
%
% Please remember to load in INDOT mile marker database and road database
% first.
%
% Inputs:
%   - lat, lon
%     The GPS coordinates for the point for which we want to get the high
%     way road name and mile marker.
%   - indotMileMarkers, indotRoads
%     Structures storing INDOT mile markers and roads respectively. Can be
%     generated by running scripts loadIndotMileMarkers.m and
%     loadIndotRoads.m respectively.
%   - UTM_STRUCT
%     Specifies the parameters for converting GPS coordinates to UTM and
%     vice versa. It will be automatically generated if
%     loadIndotMileMarkers or loadIndotRoads is run.
%   - INDOT_MILE_MARKERS_ROADNAME_LABELS
%     The road names for indotMileMarkers. This is optional but will
%     improve the speed of this function dramatically. It can be generated
%     by this function itself if it's not provided.
%
% Outputs:
%   - roadName
%     The road road name for the input point.
%   - mile
%     A float value. The mile marker for the input point.
%   - INDOT_MILE_MARKERS_ROADNAME_LABELS
%     The road names for indotMileMarkers. This is optional but storing
%     this somewhere and using it as the input for the future use of this
%     function will improve the speed of this function dramatically.
%   - nearestDist
%     The distance from the input point to the neareast road segment.
%
% Yaguang Zhang, Purdue, 02/02/2021

LOC_INDOT_MILE_MARKERS_ROADNAME_LABELS = 6;

% Get all mile markers on that road.
if nargin == LOC_INDOT_MILE_MARKERS_ROADNAME_LABELS-1
    INDOT_MILE_MARKERS_ROADNAME_LABELS = ...
        getRoadNamesForMileMarkers(indotMileMarkers);
end

roadName = '';
mile = nan;

% Project the coordinates into UMT system.
[X, Y] = mfwdtran(UTM_STRUCT, lat, lon);

% First, we need to know the name of the road we are on.

% Find the nearest road segment(s).
nearestSegs = findNearestRoadSeg(X, Y, indotRoads, 0);

% If no nearest road segment is found, print an error.
if isempty(nearestSegs)
    warning('Couldn''t find the nearest road segment!');
    return
end

% Get their road name(s).
roadName = getRoadNamesForRoadSegs(nearestSegs);

% It's not likely that the input point has more than one "nearest"
% segments. When this happens, we will check the road names for those
% segments and print a warning if they don't match.
if ~all(strcmp(roadName,roadName{1}))
    warning('Multiple road name candidates discovered!');
end
roadName = roadName{1};

% Next we need to compute the mile marker according to the road name we've
% gotten.
mileMarkersOnThisRoad = getMileMarkersByRoadName( ...
    roadName, indotMileMarkers);

% We can get all road segments if we want to. But the length of the
% segments varies from 0 to 13.15 miles, which is troublesome to deal with.
%
% if ~exist('INDOT_ROAD_SEGS_ROADNAME_LABELS', 'var')
%     INDOT_ROAD_SEGS_ROADNAME_LABELS = ...
%         getRoadNamesForRoadSegs(indotRoads);
% end roadSegsOnThisRoad = getRoadSegsByRoadName(roadName, ...
%     indotRoads, INDOT_ROAD_SEGS_ROADNAME_LABELS);

% Get the nearest 2 mile markers. Here we only use them to estimate the
% mile post for the input point.
locationsMileMarkersOnThisRoad = zeros(length(mileMarkersOnThisRoad),2);
for idx = 1:length(mileMarkersOnThisRoad)
    locationsMileMarkersOnThisRoad(idx,1) = mileMarkersOnThisRoad(idx).X;
    locationsMileMarkersOnThisRoad(idx,2) = mileMarkersOnThisRoad(idx).Y;
end
distMileMarkers = pdist2([X,Y],locationsMileMarkersOnThisRoad);
sortedDistMileMarkersWithIndices = sortrows([distMileMarkers', ...
    (1:length(distMileMarkers))'], 1);
nearest2Markers = mileMarkersOnThisRoad(...
    sortedDistMileMarkersWithIndices(1:2,2)...
    );

% Get the vector of the 2 markers from the marker with smaller postnumber.
unitMileVector = [nearest2Markers(2).X - nearest2Markers(1).X, ...
    nearest2Markers(2).Y - nearest2Markers(1).Y];
postNumNearest2Markers = nan(2,1);
for idxNearestMM = 1:2
    [~, postNumNearest2Markers(idxNearestMM)] ...
        = getRoadNameFromMileMarker(nearest2Markers(idxNearestMM));
end
if postNumNearest2Markers(1) > postNumNearest2Markers(2)
    unitMileVector = -unitMileVector;
    % Also compute the vector from the marker with smaller postnumber to
    % the input point.
    inputMileVector = [X - nearest2Markers(2).X, Y - nearest2Markers(2).Y];
else
    inputMileVector = [X - nearest2Markers(1).X, Y - nearest2Markers(1).Y];
end

% Compute the postnumber for the input point.
mile = min(postNumNearest2Markers) + ...
    dot(inputMileVector, unitMileVector) / ...
    dot(unitMileVector, unitMileVector);

end
% EOF